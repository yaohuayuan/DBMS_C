# 核心数据结构定义手册

## 1. 引言

本手册旨在详细介绍NewDBMS项目中的核心数据结构，帮助低年级同学理解数据库系统的内部实现机制。这些数据结构是NewDBMS的基础，构成了数据库系统的各个核心组件。

## 2. 数据结构分类

NewDBMS的核心数据结构按照功能可以分为以下几类：

- **文件管理类**：BlockID、Page
- **缓冲管理类**：Buffer
- **事务管理类**：Transaction
- **记录管理类**：RID、Schema、Layout、RecordPage
- **查询执行类**：Constant、Term、Predicate、Expression

## 3. 核心数据结构详细定义

### 3.1 BlockID（文件管理类）

**定义位置**：`e:/Project/NewDBMS/File/BlockID.h`

**用途**：唯一标识磁盘上的一个数据块，是文件管理的基础单元。

**数据结构定义**：
```c
typedef struct BlockID {
    CString *fileName;  // 文件名
    int BlockID;        // 块编号
} BlockID;
```

**成员变量说明**：
- `fileName`：数据块所属的文件名，使用自定义的CString类型。
- `BlockID`：数据块在文件中的唯一编号，从0开始递增。

**使用场景**：
- 在文件管理器中标识和定位数据块
- 在缓冲区管理中标识缓冲帧对应的磁盘块
- 在事务管理中跟踪事务操作的数据块

**设计特点**：
- 简单的组合结构，通过文件名和块编号唯一确定一个数据块
- 支持比较操作，可以判断两个BlockID是否指向同一个数据块

### 3.2 Page（文件管理类）

**定义位置**：`e:/Project/NewDBMS/File/Page.h`

**用途**：内存中的数据页，对应磁盘上的一个Block，提供了对页内数据的读写操作。

**数据结构定义**：
```c
typedef struct Page {
    ByteBuffer *buffer;  // 存储页数据的字节缓冲区
} Page;
```

**成员变量说明**：
- `buffer`：存储页数据的字节缓冲区，使用自定义的ByteBuffer类型，提供高效的字节数据处理。

**使用场景**：
- 在文件管理器中读写数据块
- 在缓冲区中存储数据块的内容
- 在记录管理中操作页内的记录

**设计特点**：
- 封装了字节缓冲区，提供了更高级别的数据访问接口
- 支持多种数据类型的读写操作（int、long、float、double、字符串等）
- 与磁盘块一一对应，是内存和磁盘之间的数据交换单位

### 3.3 Buffer（缓冲管理类）

**定义位置**：`e:/Project/NewDBMS/buffer/Buffer.h`

**用途**：缓冲池中的缓冲帧，用于缓存磁盘块到内存，包含了管理缓冲帧的元数据。

**数据结构定义**：
```c
typedef struct Buffer {
    FileManager *fileManager;  // 文件管理器
    LogManager *logManager;    // 日志管理器
    Page *page;                // 页数据
    BlockID *blockId;          // 对应的块ID
    int pins;                  // 引用计数
    int txNum;                 // 最后修改该缓冲区的事务号
    int lsn;                   // 最后修改的日志序列号
    time_t lastUsed;           // 最近使用时间
    int frame_id;              // 帧ID
} Buffer;
```

**成员变量说明**：
- `fileManager`：指向文件管理器的指针，用于读写磁盘块。
- `logManager`：指向日志管理器的指针，用于记录日志。
- `page`：指向页数据的指针，存储了缓冲的页内容。
- `blockId`：指向对应的块ID，标识缓冲帧对应的磁盘块。
- `pins`：引用计数，记录当前缓冲帧被多少个事务或进程引用。
- `txNum`：最后修改该缓冲区的事务号，用于事务管理。
- `lsn`：最后修改的日志序列号，用于恢复操作。
- `lastUsed`：最近使用时间，用于LRU页面替换算法。
- `frame_id`：帧ID，标识缓冲帧在缓冲池中的位置。

**使用场景**：
- 在缓冲池中管理内存中的数据块
- 实现数据块的缓存和替换策略
- 支持事务的并发控制和恢复

**设计特点**：
- 包含了完整的缓冲帧管理元数据
- 支持引用计数机制，防止缓冲帧被错误释放
- 包含了事务和日志信息，支持事务的ACID特性
- 支持LRU页面替换算法

### 3.4 Transaction（事务管理类）

**定义位置**：`e:/Project/NewDBMS/tx/Transaction.h`

**用途**：表示一个数据库事务，包含了事务的状态和相关的管理组件。

**数据结构定义**：
```c
typedef enum {
    TX_TRANSACTION_COMMIT,  // 已提交
    TX_TRANSACTION_ROLLBACK,  // 已回滚
    TX_TRANSACTION_RUN,  // 正在运行
    TX_TRANSACTION_RECOVERY,
} TransactionStatus;

typedef struct Transaction {
    TransactionStatus code;                 // 事务状态
    RecoveryManager *recoveryManager;       // 恢复管理器
    ConCurrencyManager *conCurrencyManager; // 并发管理器
    BufferManager *bufferManager;           // 缓冲池管理器
    FileManager *fileManager;               // 文件管理器
    int txNum;                              // 事务号
    BufferList *bufferList;                 // 事务使用的缓冲区列表
} Transaction;
```

**成员变量说明**：
- `code`：事务状态，包括已提交、已回滚、正在运行和恢复中。
- `recoveryManager`：指向恢复管理器的指针，负责事务的恢复操作。
- `conCurrencyManager`：指向并发管理器的指针，负责事务的并发控制。
- `bufferManager`：指向缓冲池管理器的指针，负责缓冲帧的管理。
- `fileManager`：指向文件管理器的指针，负责文件操作。
- `txNum`：事务号，唯一标识一个事务。
- `bufferList`：事务使用的缓冲区列表，管理事务操作的所有缓冲帧。

**使用场景**：
- 表示和管理数据库事务
- 协调事务的并发控制和恢复操作
- 管理事务使用的资源

**设计特点**：
- 封装了事务的完整状态和管理组件
- 支持事务的提交、回滚和恢复操作
- 包含了事务相关的所有资源管理

### 3.5 RID（记录管理类）

**定义位置**：`e:/Project/NewDBMS/record/RID.h`

**用途**：记录标识符，用于唯一标识表中的一条记录。

**数据结构定义**：
```c
typedef struct RID {
    int BlockNum;  // 块号
    int Slot;      // 槽号
} RID;
```

**成员变量说明**：
- `BlockNum`：记录所在的数据块编号。
- `Slot`：记录在数据块中的槽位编号。

**使用场景**：
- 在记录管理器中标识和定位记录
- 在查询执行中跟踪查询结果的记录
- 在索引管理中作为索引项的值

**设计特点**：
- 简单的组合结构，通过块号和槽号唯一确定一条记录
- 支持比较操作，可以判断两个RID是否指向同一条记录
- 紧凑的表示，占用空间小，适合作为索引项

### 3.6 Schema（记录管理类）

**定义位置**：`e:/Project/NewDBMS/record/Schema.h`

**用途**：定义表的模式，包含字段的名称、类型和长度等信息。

**数据结构定义**：
```c
// 文件信息类型枚举
typedef enum {
    FILE_INFO_CODE_BIT,
    FILE_INFO_CODE_TINYINT,
    FILE_INFO_CODE_SMALLINT,
    FILE_INFO_CODE_INTEGER,
    FILE_INFO_CODE_BIGINT,
    FILE_INFO_CODE_FLOAT,
    FILE_INFO_CODE_REAL,
    FILE_INFO_CODE_DOUBLE,
    FILE_INFO_CODE_NUMERIC,
    FILE_INFO_CODE_DECIMAL,
    FILE_INFO_CODE_CHAR,
    FILE_INFO_CODE_VARCHAR,
    FILE_INFO_CODE_LONG_VARCHAR,
    FILE_INFO_CODE_DATE,
    FILE_INFO_CODE_TIME,
    FILE_INFO_CODE_TIMESTAMP,
    FILE_INFO_CODE_BINARY,
    FILE_INFO_CODE_OTHER,
    FILE_INFO_CODE_NULL,
} FileInfoCode;

// 字段节点结构体
typedef struct FieldNode {
    char *fileName;
    int type;
    int length;
    struct FieldNode *next;
} FieldNode;

// 模式结构体
typedef struct Schema {
    FieldNode *fields;             // 字段链表
    map_FileInfo_t *MapFileInfo;   // 字段信息映射表
} Schema;
```

**成员变量说明**：
- `fields`：字段链表，存储表的所有字段。
- `MapFileInfo`：字段信息映射表，通过字段名快速查找字段信息。

**FieldNode成员说明**：
- `fileName`：字段名。
- `type`：字段类型，使用FileInfoCode枚举值。
- `length`：字段长度，对于定长类型表示实际长度，对于变长类型表示最大长度。
- `next`：指向下一个字段节点的指针。

**使用场景**：
- 定义表的结构
- 在记录管理中确定记录的格式
- 在查询执行中验证字段类型和长度
- 在元数据管理中存储表的模式信息

**设计特点**：
- 支持多种数据类型
- 使用链表和映射表双重结构，兼顾遍历和快速查找
- 支持灵活的字段定义

### 3.7 Layout（记录管理类）

**定义位置**：`e:/Project/NewDBMS/record/Layout.h`

**用途**：定义记录在页中的布局，包括字段的偏移量和槽大小。

**数据结构定义**：
```c
typedef struct Layout {
    Schema *schema;       // 表模式
    map_int_t *offsets;   // 字段偏移量映射
    int SlotSize;         // 槽大小
} Layout;
```

**成员变量说明**：
- `schema`：指向表模式的指针，定义了表的字段结构。
- `offsets`：字段偏移量映射，通过字段名快速查找字段在记录中的偏移量。
- `SlotSize`：记录槽的大小，即每条记录占用的字节数。

**使用场景**：
- 在记录页中定位和访问字段
- 计算记录的大小和布局
- 在记录插入和更新时确定字段的位置

**设计特点**：
- 结合了表模式和物理布局信息
- 支持快速查找字段偏移量
- 封装了记录布局的计算逻辑

### 3.8 RecordPage（记录管理类）

**定义位置**：`e:/Project/NewDBMS/record/RecordPage.h`

**用途**：表示一个存储记录的页，提供了对页中记录的操作。

**数据结构定义**：
```c
typedef enum RecordPageCode {
    RECORD_PAGE_EMPTY,  // 空槽
    RECORD_PAGE_USED    // 已使用槽
} RecordCode;

typedef struct RecordPage {
    Transaction *transaction;  // 事务
    BlockID *blockId;          // 块ID
    Layout *layout;            // 记录布局
} RecordPage;
```

**成员变量说明**：
- `transaction`：指向事务的指针，用于事务管理。
- `blockId`：指向块ID的指针，标识记录页对应的磁盘块。
- `layout`：指向记录布局的指针，定义了记录的格式。

**使用场景**：
- 在记录管理器中操作页内的记录
- 实现记录的插入、删除和更新
- 支持记录的顺序访问

**设计特点**：
- 结合了事务、块ID和记录布局信息
- 封装了记录页的操作逻辑
- 支持记录的状态管理（空槽/已使用槽）

### 3.9 Constant（查询执行类）

**定义位置**：`e:/Project/NewDBMS/query/Constant.h`

**用途**：表示查询中的常量值，支持多种数据类型。

**数据结构定义**：
```c
typedef enum {
    CONSTANT_TYPE_INT,
    CONSTANT_TYPE_FLOAT,
    CONSTANT_TYPE_STRING,
} ConstantType;

typedef struct Constant {
    ConstantType type;  // 常量类型
    union {
        int iVal;       // 整数值
        float fVal;     // 浮点值
        char *sVal;     // 字符串值
    } data;             // 常量数据
} Constant;
```

**成员变量说明**：
- `type`：常量类型，包括整数、浮点数和字符串。
- `data`：常量数据，使用联合体存储不同类型的值。

**使用场景**：
- 在查询执行中表示常量值
- 在谓词中作为比较操作数
- 在表达式求值中使用

**设计特点**：
- 使用联合体存储不同类型的值，节省空间
- 支持多种数据类型
- 支持比较操作，可以比较两个Constant的值

### 3.10 Term（查询执行类）

**定义位置**：`e:/Project/NewDBMS/query/Term.h`

**用途**：表示查询中的条件项，由字段名、运算符和常量组成。

**数据结构定义**：
```c
typedef struct Term {
    Expression *lhs;  // 左操作数（通常是字段）
    Expression *rhs;  // 右操作数（通常是常量）
    int op;           // 运算符（=, <, >, <=, >=, !=）
} Term;
```

**成员变量说明**：
- `lhs`：左操作数，通常是字段表达式。
- `rhs`：右操作数，通常是常量表达式。
- `op`：运算符，表示比较类型。

**使用场景**：
- 在查询的WHERE子句中表示条件
- 在谓词中作为条件项
- 在选择操作中过滤记录

**设计特点**：
- 支持多种比较运算符
- 结合了表达式和运算符
- 支持条件的求值操作

### 3.11 Predicate（查询执行类）

**定义位置**：`e:/Project/NewDBMS/query/Predicate.h`

**用途**：表示查询中的谓词，由多个Term组成，用于过滤记录。

**数据结构定义**：
```c
typedef struct Predicate {
    Term *terms;  // 条件项数组
    int termCount;  // 条件项数量
} Predicate;
```

**成员变量说明**：
- `terms`：条件项数组，存储谓词包含的所有条件项。
- `termCount`：条件项数量。

**使用场景**：
- 在查询的WHERE子句中表示过滤条件
- 在选择操作中过滤记录
- 支持复杂的逻辑条件

**设计特点**：
- 支持多个条件项的组合
- 支持AND和OR逻辑操作
- 支持谓词的求值操作

## 4. 数据结构之间的关系

### 4.1 层次关系

NewDBMS的数据结构呈现出清晰的层次关系：

1. **底层数据结构**：BlockID、Page
2. **缓冲管理**：Buffer
3. **记录管理**：RID、Schema、Layout、RecordPage
4. **事务管理**：Transaction
5. **查询执行**：Constant、Term、Predicate

### 4.2 依赖关系

数据结构之间的依赖关系如下：

- **Transaction**依赖**BufferManager**、**FileManager**、**RecoveryManager**和**ConCurrencyManager**
- **Buffer**依赖**FileManager**、**LogManager**和**Page**
- **RecordPage**依赖**Transaction**、**BlockID**和**Layout**
- **Layout**依赖**Schema**
- **Predicate**依赖**Term**
- **Term**依赖**Expression**和**Constant**

### 4.3 协作关系

数据结构之间的协作关系如下：

1. **文件操作**：FileManager使用BlockID标识数据块，使用Page读写数据块
2. **缓冲管理**：BufferManager使用Buffer缓存Page，使用BlockID关联磁盘块
3. **记录管理**：RecordManager使用RecordPage管理记录，使用RID标识记录，使用Layout定义记录格式
4. **事务处理**：Transaction使用BufferManager管理缓冲，使用RecoveryManager处理恢复，使用ConCurrencyManager处理并发
5. **查询执行**：QueryProcessor使用Predicate过滤记录，使用Constant表示常量，使用Term表示条件项

## 5. 数据结构设计原则

NewDBMS的核心数据结构设计遵循以下原则：

1. **封装性**：每个数据结构封装了相关的状态和操作，隐藏了内部实现细节
2. **模块化**：数据结构按照功能模块化，便于维护和扩展
3. **高效性**：数据结构设计考虑了性能，使用高效的存储方式和访问机制
4. **可扩展性**：数据结构设计支持后续扩展，便于添加新功能
5. **一致性**：数据结构之间保持一致的设计风格和命名规范

## 6. 使用示例

### 6.1 BlockID使用示例

```c
// 创建BlockID
BlockID *blockId = createBlockID("test.tbl", 0);

// 获取文件名和块编号
CString *fileName = blockId->fileName;
int blockNum = blockId->BlockID;

// 释放BlockID
destroyBlockID(blockId);
```

### 6.2 Transaction使用示例

```c
// 创建事务
Transaction *tx = createTransaction(fileManager, logManager, bufferManager);

// 开始事务操作
// ...

// 提交事务
commitTransaction(tx);

// 释放事务
destroyTransaction(tx);
```

### 6.3 RecordPage使用示例

```c
// 创建RecordPage
RecordPage *recordPage = createRecordPage(tx, blockId, layout);

// 插入记录
RID rid;
insertRecord(recordPage, &rid);

// 更新记录
setInt(recordPage, &rid, "id", 100);
setString(recordPage, &rid, "name", "test");

// 删除记录
deleteRecord(recordPage, &rid);

// 关闭RecordPage
closeRecordPage(recordPage);
```

## 7. 总结

NewDBMS的核心数据结构构成了数据库系统的基础，它们之间相互协作，实现了数据库系统的各种功能。理解这些数据结构的设计和使用对于掌握数据库系统的内部原理至关重要。

本手册详细介绍了NewDBMS的核心数据结构，包括它们的定义、用途、成员变量和使用场景。通过学习这些数据结构，可以更好地理解数据库系统的工作机制，为后续的学习和开发打下坚实的基础。